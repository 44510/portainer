import _ from 'lodash';
import { notifyError, notifySuccess } from '@/portainer/services/notifications';
import { AccessControlFormData } from '@/portainer/components/accessControlForm/porAccessControlFormModel';

const DOCKER_STANDALONE = 'DOCKER_STANDALONE';
const DOCKER_SWARM_MODE = 'DOCKER_SWARM_MODE';

/* @ngInject */
export default function ContainerFromTemplateFormController(
  $q,
  $async,
  Authentication,
  VolumeService,
  NetworkService,
  FormValidator,
  TemplateHelper,
  $state,
  TemplateService,
  ImageService,
  ContainerService,
  ResourceControlService,
  StateManager
) {
  this.$onInit = $onInit.bind(this);
  this.onSubmit = createTemplate.bind(this);
  this.addVolume = addVolume.bind(this);
  this.removeVolume = removeVolume.bind(this);
  this.addPortBinding = addPortBinding.bind(this);
  this.removePortBinding = removePortBinding.bind(this);
  this.addExtraHost = addExtraHost.bind(this);
  this.removeExtraHost = removeExtraHost.bind(this);
  this.addLabel = addLabel.bind(this);
  this.removeLabel = removeLabel.bind(this);
  this.createContainerFromTemplate = createContainerFromTemplate.bind(this);
  this.validateForm = validateForm.bind(this);

  this.isAdmin = Authentication.isAdmin();

  this.formValues = {
    network: '',
    name: '',
    accessControlData: new AccessControlFormData(),
    volumes: [],
    ports: [],
    hosts: [],
    labels: [],
    env: [],
    hostname: '',
  };

  this.state = {
    actionInProgress: false,
    formValidationError: '',
  };

  async function $onInit() {
    return $async(async () => {
      const applicationState = StateManager.getState();
      const endpointMode = applicationState.endpoint.mode;
      const apiVersion = applicationState.endpoint.apiVersion;

      this.formValues = {
        name: this.template.Name || '',
        network: this.template.Network || '',
        accessControlData: new AccessControlFormData(),
        volumes: this.template.Volumes || [],
        ports: this.template.Ports || [],
        hosts: this.template.Hosts || [],
        labels: this.template.Labels || [],
        hostname: this.template.Hostname || '',
        env: this.template.Env || [],
      };

      const { volumes, networks } = await $q.all({
        volumes: VolumeService.getVolumes(),
        networks: NetworkService.networks(
          endpointMode.provider === DOCKER_STANDALONE || endpointMode.provider === DOCKER_SWARM_MODE,
          false,
          endpointMode.provider === DOCKER_SWARM_MODE && apiVersion >= 1.25
        ),
      });

      this.availableVolumes = _.orderBy(volumes.Volumes, [(volume) => volume.Name.toLowerCase()], ['asc']);
      this.availableNetworks = networks;
    });
  }

  function createTemplate() {
    const userDetails = Authentication.getUserDetails();
    const userId = userDetails.ID;
    const accessControlData = this.formValues.accessControlData;

    if (!this.validateForm(accessControlData, this.isAdmin)) {
      return;
    }

    this.state.actionInProgress = true;

    return this.createContainerFromTemplate(userId, accessControlData);
  }

  function validateForm(accessControlData, isAdmin) {
    this.state.formValidationError = '';
    const error = FormValidator.validateAccessControl(accessControlData, isAdmin);

    if (error) {
      this.state.formValidationError = error;
      return false;
    }
    return true;
  }

  function createContainerFromTemplate(userId, accessControlData) {
    return $async(async () => {
      try {
        const template = this.template;
        const templateConfiguration = TemplateService.createTemplateConfiguration(template, this.formValues);

        const generatedVolumeCount = TemplateHelper.determineRequiredGeneratedVolumeCount(this.formValues.volumes);

        const generatedVolumes = await VolumeService.createXAutoGeneratedLocalVolumes(generatedVolumeCount);

        const generatedVolumeIds = generatedVolumes.map((volume) => volume.Id);

        TemplateService.updateContainerConfigurationWithVolumes(templateConfiguration, this.formValues.volumes, generatedVolumes);

        await ImageService.pullImage(template.RegistryModel, true);
        const endpointId = +$state.params.endpointId;

        const containerResponse = await ContainerService.createAndStartContainer(endpointId, templateConfiguration);
        const resourceControl = containerResponse.Portainer.ResourceControl;
        await ResourceControlService.applyResourceControl(userId, accessControlData, resourceControl, generatedVolumeIds);

        notifySuccess('Success', 'Container successfully created');
        $state.go('docker.containers', {}, { reload: true });
      } catch (err) {
        notifyError('Failure', err, err.msg);
      } finally {
        this.state.actionInProgress = false;
      }
    });
  }

  function addVolume() {
    this.formValues.volumes.push({ containerPath: '', bind: '', readonly: false, type: 'auto' });
  }

  function removeVolume(index) {
    this.formValues.volumes.splice(index, 1);
  }

  function addPortBinding() {
    this.formValues.ports.push({ hostPort: '', containerPort: '', protocol: 'tcp' });
  }

  function removePortBinding(index) {
    this.formValues.ports.splice(index, 1);
  }

  function addExtraHost() {
    this.formValues.hosts.push('');
  }

  function removeExtraHost(index) {
    this.formValues.hosts.splice(index, 1);
  }

  function addLabel() {
    this.formValues.labels.push({ name: '', value: '' });
  }

  function removeLabel(index) {
    this.formValues.labels.splice(index, 1);
  }
}
